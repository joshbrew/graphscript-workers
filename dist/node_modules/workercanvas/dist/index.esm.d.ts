declare var b: {
    new (): {
        __listeners: {};
        proxied: any;
        style: {};
        width: any;
        left: any;
        right: any;
        top: any;
        height: any;
        readonly clientWidth: any;
        readonly clientHeight: any;
        setPointerCapture: () => void;
        releasePointerCapture: () => void;
        getBoundingClientRect: () => {
            left: any;
            top: any;
            width: any;
            height: any;
            right: any;
            bottom: any;
        };
        handleEvent: (e: any) => void;
        focus(): void;
        blur(): void;
        addEventListener(e: any, n: any): void;
        hasEventListener(e: any, n: any): boolean;
        removeEventListener(e: any, n: any): void;
        dispatchEvent(e: any, n: any): void;
    };
};
declare var w: {
    new (): {
        __listeners: any;
        addEventListener(e: any, n: any): void;
        hasEventListener(e: any, n: any): boolean;
        removeEventListener(e: any, n: any): void;
        dispatchEvent(e: any, n: any): void;
    };
};
declare var g: {
    new (): {
        targets: {};
        makeProxy: (e: any, n: any) => void;
        getProxy: (e: any) => any;
        handleEvent: (e: any, n: any) => boolean;
    };
};
declare function I(t: any): any;
declare function D(t: any): any;
declare function L(t: any, e: any): any;
declare namespace c {
    export { Y as contextmenu };
    export { d as mousedown };
    export { d as mousemove };
    export { d as mouseup };
    export { d as pointerdown };
    export { d as pointermove };
    export { d as pointerup };
    export { d as pointerlockchange };
    export { d as webkitpointerlockchange };
    export { P as focus };
    export { P as blur };
    export { d as pointerout };
    export { m as touchstart };
    export { m as touchmove };
    export { m as touchend };
    export { $ as wheel };
    export { A as keydown };
    export { A as keyup };
    export { B as deviceorientation };
    export { K as devicemotion };
    export { z as orientation };
}
declare function h(t: any): any;
declare function H(t: any): any;
declare function p(t: any, e: any, n: any, a: any): {
    functions: {
        keydown(o: any): void;
        keyup(o: any): void;
        devicemotion(o: any): void;
        deviceorientation(o: any): void;
        orientation(o: any): void;
    };
    terminate: () => void;
    id: any;
};
declare namespace v {
    export { p as initProxyElement };
    export { q as makeProxy };
    export { M as handleProxyEvent };
}
declare function _(t: any, e: any): any;
declare function U(t: any, e: any): any;
declare function V(t: any): any;
declare function E(t: any, e: any): any;
declare function x(t: any): any;
declare function N(t: any, e: any, n: any): {
    _id: any;
    width: any;
    height: any;
    worker: any;
    draw: (o: any, u: any) => void;
    update: (o: any, u: any) => void;
    clear: () => void;
    init: () => void;
    stop: () => void;
    start: () => void;
    set: (o: any, u: any) => void;
    terminate: () => void;
};
declare function R(t: any, e: any): any;
declare namespace ne {
    export { I as Renderer };
    export { N as transferCanvas };
    export { V as setupCanvas };
    export { _ as setDraw };
    export { L as drawFrame };
    export { D as clearCanvas };
    export { H as initCanvas };
    export { R as updateCanvas };
    export { U as setProps };
    export { E as startAnim };
    export { x as stopAnim };
    export { h as getCanvas };
}
declare function Y(t: any, e: any, n: any): void;
declare function d(n: any, a: any, r: any): void;
declare function P(t: any, e: any): void;
declare function m(t: any, e: any, n: any): void;
declare function $(t: any, e: any, n: any): void;
declare function A(t: any, e: any, n: any): void;
declare function B(n: any, a: any, r: any): void;
declare function K(t: any, e: any, n: any): void;
declare function z(t: any, e: any, n: any): void;
declare function q(t: any, e: any): any;
declare function M(t: any, e: any): any;
export { b as ElementProxyReceiver, w as EventDispatcher, g as ProxyManager, I as Renderer, D as clearCanvas, L as drawFrame, c as eventHandlers, h as getCanvas, H as initCanvas, p as initProxyElement, v as proxyElementWorkerRoutes, _ as setDraw, U as setProps, V as setupCanvas, E as startAnim, x as stopAnim, N as transferCanvas, R as updateCanvas, ne as workerCanvasRoutes };
