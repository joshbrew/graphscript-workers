declare var w: {
    new (): {
        __bound: any;
        __call: any;
        apply(this: Function, thisArg: any, argArray?: any): any;
        call(this: Function, thisArg: any, ...argArray: any[]): any;
        bind(this: Function, thisArg: any, ...argArray: any[]): any;
        toString(): string;
        prototype: any;
        readonly length: number;
        arguments: any;
        caller: Function;
        readonly name: string;
        [Symbol.hasInstance](value: any): boolean;
        [Symbol.metadata]: DecoratorMetadata | null;
    };
};
declare var x: {
    new (e: any): {
        data: {};
        triggers: {};
        ctr: number;
        setState: (e: any) => {};
        setValue: (e: any, t: any) => void;
        triggerEvent: (e: any, t: any) => void;
        subscribeState: (e: any) => number;
        unsubscribeState: (e: any) => boolean;
        subscribeEvent: (e: any, t: any, n: any, s: any) => number;
        unsubscribeEvent: (e: any, t: any) => boolean;
        subscribeEventOnce: (e: any, t: any) => number;
        getEvent: (e: any, t: any) => any;
        getSnapshot: () => void;
        onRemoved: any;
    };
};
declare var b: {
    new (e: any): {
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (e: any) => {};
                setValue: (e: any, t: any) => void;
                triggerEvent: (e: any, t: any) => void;
                subscribeState: (e: any) => number;
                unsubscribeState: (e: any) => boolean;
                subscribeEvent: (e: any, t: any, n: any, s: any) => number;
                unsubscribeEvent: (e: any, t: any) => boolean;
                subscribeEventOnce: (e: any, t: any) => number;
                getEvent: (e: any, t: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (e: any) => void;
        load: (e: any, t?: boolean) => any;
        setLoaders: (e: any, t: any) => any;
        runLoaders: (e: any, t: any, n: any, s: any) => void;
        add: (e: any, t: any, n?: boolean) => any;
        recursiveSet: (e: any, t: any, n: {}, s: any, r?: boolean) => {};
        remove: (e: any, t?: boolean) => any;
        run: (e: any, ...t: any[]) => any;
        setListeners: (e: any) => void;
        clearListeners: (e: any, t: any) => void;
        get: (e: any) => any;
        getByUnique: (e: any) => any;
        set: (e: any, t: any) => Map<any, any>;
        delete: (e: any) => boolean;
        list: () => any[];
        getListener: (e: any, t: any, n: any) => any;
        getProps: (e: any, t: any) => void;
        subscribe: (e: any, t: any, n: any, s: any, r: any, _: any, o: any) => number;
        unsubscribe: (e: any, t: any, n: any, s: any) => any;
        setState: (e: any) => void;
    };
};
declare var y: {
    new (e: any, t: any, n: any): {
        __node: {
            tag: string;
            unique: string;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (e: any) => {};
                setValue: (e: any, t: any) => void;
                triggerEvent: (e: any, t: any) => void;
                subscribeState: (e: any) => number;
                unsubscribeState: (e: any) => boolean;
                subscribeEvent: (e: any, t: any, n: any, s: any) => number;
                unsubscribeEvent: (e: any, t: any) => boolean;
                subscribeEventOnce: (e: any, t: any) => number;
                getEvent: (e: any, t: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
        };
        __children: any;
        __parent: any;
        __operator: any;
        __listeners: any;
        __props: any;
        __args: any;
        __graph: any;
        __setProperties: (e: any, t: any, n: any) => void;
        __onconnected: any;
        __ondisconnected: any;
        __subscribe: (e: any, t: any, n: any, s: any, r: any, _: any, o: any) => number;
        __unsubscribe: (e: any, t: any, n: any) => boolean;
        __setOperator: (e: any) => any;
        __subscribedToParent: boolean;
        __addLocalState: (e: any, t: any) => void;
        __proxyObject: (e: any) => void;
        __addOnconnected(e: any): void;
        __addOndisconnected(e: any): void;
        __callConnected(e?: any): void;
        __callDisconnected(e?: any): void;
    };
};
declare var L: {
    new (e: any): {
        name: string;
        restrict: any;
        addServices: (e: any) => void;
        set: (e: any, t: any) => Map<any, any>;
        delete: (e: any) => boolean;
        handleMethod: (e: any, t: any, n: any) => any;
        handleServiceMessage(e: any): any;
        handleGraphNodeCall(e: any, t: any): any;
        transmit: (...e: any[]) => any;
        receive: (...e: any[]) => any;
        pipe: (e: any, t: any, n: any, s: any, r: any) => number;
        pipeOnce: (e: any, t: any, n: any, s: any, r: any) => number;
        terminate: (...e: any[]) => void;
        isTypedArray: typeof X;
        recursivelyAssign: (i: any, e: any) => any;
        spliceTypedArray: typeof Y;
        ping: () => string;
        echo: (...e: any[]) => any[];
        log: (...e: any[]) => boolean;
        error: (...e: any[]) => boolean;
        __node: {
            tag: string;
            unique: string;
            nodes: Map<any, any>;
            state: {
                data: {};
                triggers: {};
                ctr: number;
                setState: (e: any) => {};
                setValue: (e: any, t: any) => void;
                triggerEvent: (e: any, t: any) => void;
                subscribeState: (e: any) => number;
                unsubscribeState: (e: any) => boolean;
                subscribeEvent: (e: any, t: any, n: any, s: any) => number;
                unsubscribeEvent: (e: any, t: any) => boolean;
                subscribeEventOnce: (e: any, t: any) => number;
                getEvent: (e: any, t: any) => any;
                getSnapshot: () => void;
                onRemoved: any;
            };
            roots: {};
        };
        init: (e: any) => void;
        load: (e: any, t?: boolean) => any;
        setLoaders: (e: any, t: any) => any;
        runLoaders: (e: any, t: any, n: any, s: any) => void;
        add: (e: any, t: any, n?: boolean) => any;
        recursiveSet: (e: any, t: any, n: {}, s: any, r?: boolean) => {};
        remove: (e: any, t?: boolean) => any;
        run: (e: any, ...t: any[]) => any;
        setListeners: (e: any) => void;
        clearListeners: (e: any, t: any) => void;
        get: (e: any) => any;
        getByUnique: (e: any) => any;
        list: () => any[];
        getListener: (e: any, t: any, n: any) => any;
        getProps: (e: any, t: any) => void;
        subscribe: (e: any, t: any, n: any, s: any, r: any, _: any, o: any) => number;
        unsubscribe: (e: any, t: any, n: any, s: any) => any;
        setState: (e: any) => void;
    };
};
declare function $(i: any, e: any, t: any): void;
declare function C(i: any, e: any, t: any): void;
declare function V(i: any, e: any, t: any): void;
declare function J(i: any, e: any, t: any): void;
declare function I(i: any): any[];
declare function A(i: any, e: any): (..._: any[]) => any;
declare function se(i: any): any;
declare function D(i: any): any;
declare function v(i: any): {};
declare function R(i: any): "function" | "class" | "async" | "arrow" | "";
declare function S(i: any): boolean;
declare function X(i: any): boolean;
declare namespace F {
    export { C as backprop };
    export { T as loop };
    export { $ as animate };
    export { J as branching };
    export { W as triggerListenerOncreate };
    export { V as bindListener };
    export { B as transformListenerResult };
    export { H as substitute__operator };
}
declare function T(i: any, e: any, t: any): void;
declare function ae(i: any): void;
declare function P(i?: string): any;
declare function re(i?: string): any;
declare function M(i: any, e: any): any;
declare function U(i: any): {};
declare function Y(i: any, e: any, t: any): any;
declare var q: {
    data: {};
    triggers: {};
    ctr: number;
    setState: (e: any) => {};
    setValue: (e: any, t: any) => void;
    triggerEvent: (e: any, t: any) => void;
    subscribeState: (e: any) => number;
    unsubscribeState: (e: any) => boolean;
    subscribeEvent: (e: any, t: any, n: any, s: any) => number;
    unsubscribeEvent: (e: any, t: any) => boolean;
    subscribeEventOnce: (e: any, t: any) => number;
    getEvent: (e: any, t: any) => any;
    getSnapshot: () => void;
    onRemoved: any;
};
declare function Q(o: any, a: any): string;
declare function k(o: any, a: any): string;
declare function z(o: any, a: any): string;
declare function H(i: any, e: any, t: any): void;
declare function B(i: any, e: any, t: any): void;
declare function W(i: any, e: any, t: any): void;
declare function j(i: any, e: any, t: any): {
    __callback: any;
    __args: any[];
};
export { w as Callable, x as EventHandler, b as Graph, y as GraphNode, L as Service, $ as animate, C as backprop, V as bindListener, J as branching, I as getAllProperties, A as getCallbackFromString, se as getFnParamNames, D as getFunctionHead, v as instanceObject, R as isFunction, S as isNativeClass, X as isTypedArray, F as loaders, T as loop, ae as methodstrings, P as parseFunctionFromText, re as reconstructObject, M as recursivelyAssign, U as recursivelyStringifyFunctions, Y as spliceTypedArray, q as state, Q as stringifyFast, k as stringifyWithCircularRefs, z as stringifyWithFunctionsAndCircularRefs, H as substitute__operator, B as transformListenerResult, W as triggerListenerOncreate, j as wrapArgs };
